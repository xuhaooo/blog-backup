## 一、单线程模式
### 1. 定义
- 单线程模式：JavaScript 只在一个线程上运行，即 JavaScript 同时只能执行一个任务，其他的任务必须在后面排队等待
- 注意，只在一个线程上运行，并不代表 JS 引擎只有一个线程，其实 JS 引擎拥有多个线程，单个脚本只能在一个线程（主线程）上运行，其它线程在后台配合
### 2. 背景
> JS 诞生之初就被设计成了单线程，因为多线程需要共享资源、可能彼此修改运行结果，这样对于一个网页脚本语言来说，太重太过复杂了。比如说，如果 JS 同时有两个线程，一个线程在网页上添加一个 dom 节点，另一个线程删除这个网页节点，浏览器就不知道该咋办了
### 3. 优缺点
#### 优点
实现简单，执行环境要求低
#### 缺点
> 如果一个任务执行时间较长，那后续的任务必须排队等待，这样会拖慢整个程序的执行，常见如浏览器卡死，往往就是因为一段程序长时间执行，导致整个页面卡死，其他任务无法执行，比如写了一个死循环或者等待 AJAX 请求返回数据而对方服务器迟迟没有响应
### 4. 优化
如果排队是因为计算量大，CPU 处理不过来，那还可以理解。但是很多时候 CPU 都是闲着的，因为 IO 操作（输入输出）非常慢，比如 AJAX 从网页读取数据，CPU 不得不等着结果出来再进行下一步操作。这个时候，JS 的设计者就意识到，可以不管 IO 操作把处于等待中的任务挂起来，先运行后面的操作，等 IO 操作返回了结果之后，再回过头来执行挂起的任务，这就是 JS 内部的事件循环机制（Event Loop）

## 二、同步任务 V.S. 异步任务
### 1. 同步任务
- JS 引擎中没有被挂起，需要在主线程上排队等待执行的任务
- 同步任务只有执行完一个，才会执行下一个
### 2. 异步任务
- 被 JS 引擎挂起，不进入主线程而进入"任务队列"的任务
- 只有当 JS 引擎认为这个异步任务可以执行了，该任务才会进入主线程执行
- 排在异步任务之后的代码，不会等待异步任务执行完才执行，而是会立即执行，也就是说异步任务不会造成阻塞
### 3. 举例说明
#### 同步任务 --- 能直接拿到结果
- 比如，去医院挂号，只有在挂号窗口拿到结果才会离开
- 同步任务可能需要 10 毫秒，也可能需要 10 毫秒，总之没有拿到结果（执行完毕）之前是不会离开的
#### 异步任务 --- 不能直接拿到结果
- 比如，去餐厅门口拿号，拿到号之后你可以去干别的事情
- 至于什么时候能吃上饭
- 可以每 10 分钟去餐厅门口问一下 --- 轮询（有点傻）
- 也可以通过扫码用微信接受叫号通知 --- 回调
- 异步任务不会立即拿到结果，至于是通过轮询还是回调拿到结果，这个只是形式不同
#### 总结
一个任务（程序）是被当做同步任务处理，还是被当做异步任务处理，是由开发者决定的；如果是同步任务，那主线程就等待任务结束拿到了结果之后，才会向下执行；如果是异步任务，主线程就在挂起异步任务之后，直接向下执行，等异步任务有了结果之后，主线程再回头执行对应的回调

## 三、任务队列与事件循环
### 1. 任务队列
- JS 运行的时候，除了一个正在运行的主线程，JS 引擎还提供一个任务队列，里面是各种需要等待处理的异步任务
- JS 处理同步任务、异步任务的过程如下：
- 首先，主线程会去执行执行所有的同步任务，等同步任务全部处理完，再去看任务队列里的异步任务
- 注意，所有的同步任务都会得到优先处理，即使任务队列里的一个异步任务已经得到了结果，也得等所有同步任务处理完才会得到处理
- 继续，等所有同步任务处理完，如果一个异步任务满足条件，那么它会重新进入主线程开始执行，这个时候就会变成同步任务
- 依次地，下一个异步任务进入主线程执行，一旦任务队列被清空了，程序也就结束了执行
### 2. 异步任务的写法
- 异步任务的写法通常是回调函数，一旦一个异步任务进入了主线程，就会执行相应的回调函数
- 如果一个异步任务没有回调函数，那么它就不会进入任务队列，即不会重新进入主线程，因为没有回调函数指定下一步操作
### 3. 事件循环
- 看到上面，你可能会有一个疑问：JS 引擎是如何知道异步任务有没有结果，能不能进入主线程呢？
- 答案：JS 引擎会不停的检查（就是上面提到的轮询），只要所有的同步任务执行完了，引擎就会检查任务队列中的那些异步任务，看有没有可以进入主线程执行的
- 这种循环检查的机制，叫做事件循环（Event Loop）

## 四、异步操作模式
### 1. 回调函数 (callback)
```js
function f1() { 
    //... 
}
function f2(fn) {
    fn()
}
f2(f1)
```
#### 定义
- 我写给**别人**调用的函数
- 即，你**回**头**调**用一下这个函数
- 比如，之前 AJAX 里面 `readystatechange` 之后的函数就是我写给浏览器调用的
#### 回调与异步任务的关系
##### 1. 关联
- 异步任务需要在得出结果之后通知 JS 引擎来拿，怎么通知呢？
- 可以留一个函数地址（电话号码）给 JS 引擎
- 异步任务在得到结果之后调用该函数地址即可（打电话）
- 同时把结果作为参数传递给该函数（你可以来吃饭了）
- 异步任务需要通过回调的方式，把得到的结果通知给 JS 引擎
##### 2. 区别
- 异步任务需要用回调函数的方式来通知结果
- 但是回调函数不一定必须用在异步任务中，它们是合作关系
- 比如拿号吃饭的例子中，我不一定需要通过等待通知的方式知道什么时候可以吃饭，也可以通过轮询即每几分钟去问一下
- 另外，回调也可以用在同步任务中
```js
array.forEach(n=>console.log(n))
// 这里的 n=>console.log(n) 就是同步回调
// 数组中有多少元素 forEach 就会立即调用传入的回调函数多少次
```

### 2. 定时器
> JS 提供的定时执行代码的功能，主要由 `setTimeout`、`setInterval`两个函数来完成，他们向任务队列添加定时任务。运行机制将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，指定的任务，一定会按照预定时间执行。另外不会产生累计效应。
#### setTimeout()
- 用来指定某个函数或代码，在多少毫秒之后执行
- 它返回一个整数，表示定时器的编号，用于之后取消这个定时器
```js
let timer = setTimeout(fn|code, delay)

setTimeout('console.log(2)', 1000) // 代码的字符串形式
function fn() {
    console.log(2)
}
setTimeout(fn, 1000) // 函数定义或函数名形式
```
- 除了前两个参数，它可以接受多个参数，将依次传入回调函数中

#### setInterval()
- 用法与 `setTimeout()` 完全一致
- 区别仅在于它是指定某个任务**每隔一段时间**就执行一次，即无限次的定时执行
- 注意，`setInterval()` 指定的是**开始执行**之间的时间间隔，并不考虑每次执行任务本身所消耗的时间
- 比如，指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始；如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始
- 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间
```js
let timer = setTimeout(function f() {
  // ...
  timer = setTimeout(f, 2000);
}, 2000);
// 下一次执行总是在本次执行结束之后的 2000 毫秒开始
```
#### 取消定时器
- 上述两个函数都会返回一个整数，表示定时器编号
- 将该编号传入 `clearTimeout()`、`clearInterval()` 就可以取消对应的定时器，即定时器内回调函数不会再执行了
- 注意 `setTimeout()`、`setInterval()` 返回的整数值都是连续的

### 3. 如何判断一个函数是否是异步任务？
- 如果这个函数处于：定时器、AJAX、addEventListener 中
- 那这个函数就是异步任务